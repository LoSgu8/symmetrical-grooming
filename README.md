# symmetrical-grooming

Net2plan-based evaluation for a network topology divided in subregions. Heuristic evaluation of which transponder type to select for each node based on transponder cost and available modulation.


## Design Choices

- The traffic matrix is randomly drawn respecting the given probabilities.
- OEO ZR+ transponders are used in metro links and OEO Long Reach transponders in core links.


## Topology
At each node is assigned a set of tags. The possible tags are "METRO", "CORE" and "IslandX". A node may have and multiple "IslandX" tags and both the tags "CORE" and "METRO" if it is on the border of zones.

At each link is assigned a single tag "CORE" or "METRO" to describe the area of belonging.


## Offline\_ipOverWdm\_routingSpectrumAndModulationAssignmentHeuristicNotGrooming.java

All the demands are ordered according to their QoSType (priority first, best-effort last) and looped through them.

In order to achieve better results in the single transponder case, demands can be satisfied from the shortest to the longest one, achieving higher levels of grooming.

At each demand it is assigned the first available shortest path. It is always preferred the use of the modualtion having the best spectral efficiency and that requires the minimum number of regenerations.
Whenever the path crosses different zones, the channel is regenerated in order to mantain different transponder in each zone.

If the first *k* (parameter) possible shortest paths don't have enough resources to satisfy the demand, the demand is not routed (error returned in case of priority traffic, simple drop in case of best effort).


## Transponder.java

Class to represents a Transponder, each transponder is characterized by a name, the cost and the list of available modulations.

* **getBestModulationFormat** method: returns the best suitable modulation given a certain path lenght (best spectral efficiency)

## Modulation.java

Class that represents a modulation, each modualtion is described by the modulation format, the datarate, the channel spacing and the maximum reach without regeneration.

## TrafficGenerator.java

The method **void generate(int numberOfDemands)** generates numberOfDemands services. In particular, for each service it randomly select a node from the list of nodes, generates a demand with QoS ("PRIORITY" or "BEST_EFFORT"). Intermediate Nodes between CORE and METRO regions are considered CORE nodes. Actually, the traffic is evenly generated by core and metro nodes but it can be easily redistributed by changing the value of the variable *probabilityOfStartingFromCore*.

Each new demand is generated from the selected node respecting the simulation proportions given below:

|           | CORE     |           | METRO    |           |
| --------- | -------- | --------- | -------- | --------- |
| SUBREGION | same     | different | same     | different |
| CORE      | 40%      | 30%       | 30%      |           |
| QOS       | Priority | Priority  | Priority |           |
| METRO     | 30%      |           | 50%      | 20%       |
| QOS       | Priority |           | 50P/50BE | 50P/50BE  |


## IPLink.java

Clas used to represent an IP link, each IP link object is characterized by a WDMUtils.RSA, the modulation used, its spare capacity and the carried demands.

## RUN MULTIPLE SIMULATIONS - launch.py

* Synopsys: 

  ```bash
  python launch.py [Net2Plan directory] [topology file] [class file] --alg-param [start °of demands] [demand increment] [% of traffic generated by CORE nodes] [bool: singlestransponder] [° of iterations per demand] [output file]
  ```

* *NOTE: each parameter after --alg-param must be preceeded by "--alg-param"*;

* runs multiple iterations of the Offline Algorithm, either in single or multiple transponder mode.

* Simulation output is returned at each increase in demand in XML format.
