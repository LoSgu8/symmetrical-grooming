import com.net2plan.interfaces.networkDesign.Net2PlanException;
import com.net2plan.interfaces.networkDesign.NetPlan;
import com.net2plan.interfaces.networkDesign.Node;
import com.net2plan.utils.*;

import java.util.*;

public class TrafficGenerator {

    private final NetPlan netPlan;
    private final double probabilityOfStartingFromCore = 0.5;

    /*
    min 350 services of 100Gbps, increase by 50 services

                   CORE      |          METRO
    SUBREGION: same | diff   |     same   |  diff
    ------------------------------------------------------
    CORE       0.4  |  0.3   |      0.3
    QOS         H   |   H    |       H
    ------------------------------------------------------
    METRO          0.3       |     0.5     |    0.2
    QOS             H        | 0.5H/0.5BE  | 0.3H/0.7BE
    ------------------------------------------------------
    */
    // CORE -> SAME CORE
    static final double CORE_TO_SAME_CORE = 0.4;
    // CORE -> DIFFERENT CORE
    static final double CORE_TO_DIFFERENT_CORE = 0.3;
    // CORE -> METRO
    //static final double CORE_TO_METRO = 0.3;

    // METRO -> SAME METRO
    static final double METRO_TO_SAME_METRO = 0.5;
    // METRO -> DIFFERENT METRO
    static final double METRO_TO_DIFFERENT_METRO = 0.2;
    // METRO -> CORE
    // static final double METRO_TO_CORE = 0.3;

    // Percentage of priority traffic from metro to a different metro
    static final double METRO_TO_DIFFERENT_METRO_PRIORITY = 0.3;
    // Percentage of priority traffic from metro to a same metro
    static final double METRO_TO_SAME_METRO_PRIORITY = 0.5;
    // Percentage of priority traffic from metro to core
    static final double METRO_TO_CORE_PRIORITY = 1;

    public TrafficGenerator(NetPlan netPlan, double probabilityOfStartingFromCore) {
        this.netPlan = netPlan;
        this.probabilityOfStartingFromCore = probabilityOfStartingFromCore;
    }

    public TrafficGenerator(NetPlan netPlan) {
        this(netPlan, 0.5);
    }

    public void generate(int numberOfDemands) {
        // Separate nodes according to their tag
        List<Node> coreNodes = new ArrayList<>(netPlan.getTaggedNodes("CORE"));
        List<Node> metroNodes = new ArrayList<>(netPlan.getTaggedNodes("METRO"));

        // Remove from metroNodes elements that are also in coreNodes
        metroNodes.removeAll(coreNodes);

        // Generate a random demand for each iteration
        for (int i = 0; i < numberOfDemands; i++) {
            Node sourceNode, destinationNode;
            String sourceType;
            String destinationIsland;
            String demandQoS;
            List<Node> destinationCandidates = new ArrayList<>();

            // Choose if the source of this demand is a core node or a metro node (probabilityOfStartingFromCore chance)
            if (Math.random() > this.probabilityOfStartingFromCore) {
                // Extract a random node from CORE node set
                int randomNodeIndex = (int) (Math.random() * coreNodes.size());
                sourceNode = coreNodes.get(randomNodeIndex);
                sourceType = "CORE";
            } else {
                // Extract a random node from METRO node set
                int randomNodeIndex = (int) (Math.random() * metroNodes.size());
                sourceNode = metroNodes.get(randomNodeIndex);
                sourceType = "METRO";
            }

            double random = Math.random();

            if (sourceType.equals("CORE")) { // CORE

                // The demands generated by core nodes have always the QoS set to PRIORITY
                demandQoS = "PRIORITY";

                if (random <= CORE_TO_SAME_CORE) { // CORE -> SAME CORE
                    // Get the set of nodes that are on the same island of the source node
                    List<Node> destinationCandidatesToSelect = new ArrayList<>(netPlan.getTaggedNodes("CORE"));
                    destinationCandidatesToSelect.remove(sourceNode);
                    List<String> sourceNodeIslands = new ArrayList<>(sourceNode.getTags());
                    sourceNodeIslands.remove("CORE");
                    sourceNodeIslands.remove("METRO");

                    // Add to destinationCandidates all nodes that are on the same island of the source node
                    for (String island : sourceNodeIslands) {
                        List<Node> nodesOnIsland = destinationCandidatesToSelect;
                        nodesOnIsland.retainAll(netPlan.getTaggedNodes(island));
                        destinationCandidates.addAll(nodesOnIsland);
                    }

                } else if (random <= CORE_TO_SAME_CORE + CORE_TO_DIFFERENT_CORE) { // CORE -> DIFFERENT CORE
                    // Get the set of nodes that are on a different island of the source node
                    List<Node> destinationCandidatesToSelect = new ArrayList<>(netPlan.getTaggedNodes("CORE"));
                    destinationCandidatesToSelect.remove(sourceNode);
                    List<String> sourceNodeIslands = new ArrayList<>(sourceNode.getTags());
                    sourceNodeIslands.remove("CORE");
                    sourceNodeIslands.remove("METRO");

                    // Add to destinationCandidates all nodes that are on a different island of the source node
                    for (String island : sourceNodeIslands) {
                        List<Node> nodesOnIsland = destinationCandidatesToSelect;
                        nodesOnIsland.removeAll(netPlan.getTaggedNodes(island));
                        destinationCandidates.addAll(nodesOnIsland);
                    }
                } else { // CORE -> METRO
                    destinationCandidates = new ArrayList<>(netPlan.getTaggedNodes("METRO"));
                }
            } else { // METRO
                if (random <= METRO_TO_SAME_METRO) { // METRO -> SAME METRO
                    // Get the set of nodes that are on the same island of the source node
                    List<Node> destinationCandidatesToSelect = new ArrayList<>(netPlan.getTaggedNodes("METRO"));
                    destinationCandidatesToSelect.remove(sourceNode);
                    List<String> sourceNodeIslands = new ArrayList<>(sourceNode.getTags());
                    sourceNodeIslands.remove("CORE");
                    sourceNodeIslands.remove("METRO");

                    // Add to destinationCandidates all nodes that are on the same island of the source node
                    for (String island : sourceNodeIslands) {
                        List<Node> nodesOnIsland = destinationCandidatesToSelect;
                        nodesOnIsland.retainAll(netPlan.getTaggedNodes(island));
                        destinationCandidates.addAll(nodesOnIsland);
                    }

                    // QoS management
                    double decision = Math.random();
                    if (decision < METRO_TO_SAME_METRO_PRIORITY) {
                        demandQoS = "PRIORITY";
                    } else {
                        demandQoS = "BEST_EFFORT";
                    }

                } else if (random <= METRO_TO_SAME_METRO + METRO_TO_DIFFERENT_METRO) { // METRO -> DIFFERENT METRO
                    // Get the set of nodes that are on a different island of the source node
                    List<Node> destinationCandidatesToSelect = new ArrayList<>(netPlan.getTaggedNodes("METRO"));
                    destinationCandidatesToSelect.remove(sourceNode);
                    List<String> sourceNodeIslands = new ArrayList<>(sourceNode.getTags());
                    sourceNodeIslands.remove("CORE");
                    sourceNodeIslands.remove("METRO");

                    // Add to destinationCandidates all nodes that are on a different island of the source node
                    for (String island : sourceNodeIslands) {
                        List<Node> nodesOnIsland = destinationCandidatesToSelect;
                        nodesOnIsland.removeAll(netPlan.getTaggedNodes(island));
                        destinationCandidates.addAll(nodesOnIsland);
                    }

                    // QoS management
                    double decision = Math.random();
                    if (decision < METRO_TO_DIFFERENT_METRO_PRIORITY) {
                        demandQoS = "PRIORITY";
                    } else {
                        demandQoS = "BEST_EFFORT";
                    }

                } else { // METRO -> CORE
                    destinationCandidates = new ArrayList<>(netPlan.getTaggedNodes("CORE"));

                    // QoS management
                    double decision = Math.random();
                    if (decision < METRO_TO_CORE_PRIORITY) {
                        demandQoS = "PRIORITY";
                    } else {
                        demandQoS = "BEST_EFFORT";
                    }
                }
            }

            // Choose destination node
            int randomNodeIndex = (int) (Math.random() * destinationCandidates.size());
            destinationNode = destinationCandidates.get(randomNodeIndex);

            // create a new demand
            netPlan.addDemand(sourceNode, destinationNode, 100, 0, 0, 0, demandQoS);
        }
    }
}


